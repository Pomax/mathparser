<!doctype html>
<html>
  <head>
    <meta charset="utf8">
    <title>A JavaScript math function library</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="toolkit/ttk-range.css">
    <link rel="stylesheet" href="tabbing/tabbing.css">
  </head>
  <body>

    <h1>A JavaScript plotting library</h1>

    <div class="column">
      <section class="tabbed" data-title="MathFunction">
        <input type="text" class="function" value="a*sin(x) - b*tan(x) + cos(x^(c/40))" style="width:400px" onchange="plot()">
        <button onclick="plot()">plot</button>
        <figure>
          <div class="plots"></div>
          <p class="prettyFormula"></p>
          <div><input type="range" class="start" min="0" max="10" step="0.01" value="0" onchange="plot()">
            (start <span class='startval'></span>)
          </div>
          <div><input type="range" class="end" min="0" max="10" step="0.01" value="10" onchange="plot()">
            (end <span class='endval'></span>)
          </div>
          <div><input type="range" class="step" min="0" max="0.01" step="0.0001" value="0.003" onchange="plot()">
            (step <span class='stepval'></span>)
          </div>
          <div class="clamps">clamped values</div>
        </figure>

        <figure class="viewbox">
          <b>VIEWBOX</b>
          minx: <input type="text" class="v_minx" value="-0.1" onchange="plot()">
          maxx: <input type="text" class="v_maxx" value="10.1" onchange="plot()">
          miny: <input type="text" class="v_miny" value="-100" onchange="plot()">
          maxy: <input type="text" class="v_maxy" value="100" onchange="plot()">
        </figure>
      </section>

      <section class="tabbed" data-title="MathFunction.Compound">
        <input type="text" class="function" value="(a^2/(a+1)^2) * tan(cos(x)+sin(x)), (b^2/(b+1)^2) * sin(x+pi/3)" style="width:400px" onchange="plot()">
        <button onclick="plot()">plot</button>
        <figure>
          <div class="plots"></div>
          <p class="prettyFormula"></p>
          <div><input type="range" class="start" min="0" max="10" step="0.01" value="0" onchange="plot()">
            (start <span class='startval'></span>)
          </div>
          <div><input type="range" class="end" min="0" max="10" step="0.01" value="6.29" onchange="plot()">
            (end <span class='endval'></span>)
          </div>
          <div><input type="range" class="step" min="0" max="0.01" step="0.00001" value="0.003" onchange="plot()">
            (step <span class='stepval'></span>)
          </div>
          <div class="clamps">clamped values</div>
        </figure>

        <figure class="viewbox">
          <b>VIEWBOX</b>
          minx: <input type="text" class="v_minx" value="-7" onchange="plot()">
          maxx: <input type="text" class="v_maxx" value="7" onchange="plot()">
          miny: <input type="text" class="v_miny" value="-1.5" onchange="plot()">
          maxy: <input type="text" class="v_maxy" value="1.5" onchange="plot()">
        </figure>

      </section>

    </div>

    <div class="column">
      <h3>A bit of API</h3>
      <p>This library gives you a <code>MathFunction</code> object, which is created
      with a function string as constructor argument, such as <code>new MathFuction("sin(x)
      - tan(x) + cos(x^2.4)")</code>. You can also set up a parametric function by using the
      <code>MathFunction.Compound</code> object, such as <code>new MathFunction.Compound("cos(x)",
      "sin(x)")</code>. If your function was balanced (i.e. all the opening parentheses have matching closing parentheses) you can use the following API (if unbalanced, the constructor throws an
      error for you to catch):</p>

      <dl>
        <dt>render(container)</dt>
        <dd>shows the function as LaTeX in [container]. If MathJax is loaded, typesets it prettily.</dd>

        <dt>plot(container, options, viewbox)</dt>
        <dd>Plots the function, based on the given options: <code>{ variable: 'var that changes', start: number,
        end: number, step: number, clamps: [ {label:'var that is clamped', value:number}, ... ]}</code>. If a
        viewbox is given, of the form <code>{minx:num, maxx:num, miny:num, maxy:num}</code>, the plot will
        be constrained to those values.</dd>
      </dl>

      <h3>Supported operations</h3>
      <p>The MathFunction object understands the following operators and functions:</p>

      <dl>
        <dt>numbers and constants</dt>
        <dd>integer and floating point numbers, supported constants: e, Ï€</dd>

        <dt>basic operators and grouping</dt>
        <dd>...+..., ...-..., ...*..., .../..., ...^..., ...!, -..., (...)</dd>

        <dt>built in functions, of the form fn(...)</dt>
        <dd>sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, ln, log, sqrt, abs</dd>

        <dt>built in aggregators, of the form fn(start, end, [function]), using "n" as control variable</dt>
        <dd>sum, prod</dd>

        <dt>special aggregators</dt>
        <dd>area(start, end, steps, varname, [function]) - this computes the naive Newtonean area
          underneath a function by, essentially, adding the areas of rectangular strips. I kind of
          want to replace this with Legendre-Gauss integration, but for now, this works.</dd>
      </dl>

      <h3>Function substitution</h3>
      <p>The MathFunction object understands variable/function substitution, using the
      <code>replace</code> function.</p>

      <dl>
        <dt>replace(varname, [string or MathFunction])</dt>
        <dd>replace all instances of a variable [varname] with the provided MathFunction
        instead, or if a string was passed, the MathFunction resulting from <code>new
        MathFunction(string)</code>.</dd>
      </dl>
    </div>

    <h1>This library is still under construction</h1>

    <script src="./head.js"></script>
    <script>
      var curFn = "",
          curMF = false,
          parameters = [],
          clamped = [];

      /**
       * plotting function based on on-page parameters
       */
      function plot() {
        var section = find('section[data-visible]'),
            fn = section.find('.function').value,
            p = section.find('.prettyFormula'),
            plotDiv = section.find('.plots'),
            mathFunction;

        /**
         * Administrative code for when a function has changed
         */
        if(curFn!=fn) {
          // bind math function
          curFn = fn;
          if(fn.indexOf(',')!==-1) {
            args = fn.split(',');
            mathFunction = new MathFunction.Compound(args);
          } else { mathFunction = new MathFunction(fn) }
          curMF = mathFunction;
          // add clamp parameters
          parameters = curMF.getParameters();
          parameters.splice(parameters.indexOf('x'),1);
          var clamps = section.find("div.clamps");
          // clean out clamps that are no longer relevant
          clamped.forEach(function(clamp) {
            if(parameters.indexOf(clamp)===-1) {
              clamps.find(".label"+clamp).remove();
              clamps.find(".label"+clamp+"label").remove();
            }
          });
          clamped = [];
          // add new clamps based on the function parameters
          parameters.forEach(function(clamp) {
            if(clamps.find(".label"+clamp).length>0) return;
            clamped.push(clamp);
            var range = create("input");
            range = range.set("type","range");
            range.set({min:0,max:100,step:1,value:1});
            range.onchange = function() { plot(); };
            range.classes().add("label"+clamp);
            clamps.add(range);
            clamps.add(create("span",{"class":"label"+clamp+"label"},clamp));
          });
        } else { mathFunction = curMF; }

        // show formula on the page
        mathFunction.render(p);

        // get the variable plotting values
        var start = parseFloat(section.find('div[type=range].start').get("value")),
            end   = parseFloat(section.find('div[type=range].end').get("value")),
            step  = parseFloat(section.find('div[type=range].step').get("value"));

        if(end<start) {
          end = start + 0.1;
          section.querySelector('div[type=range].end').set("value",end); }

        step = (step>0 ? step : 0.001);
        section.find('.startval').innerHTML = Math.round(start*1000)/1000;
        section.find('.endval').innerHTML   = Math.round(end*1000)/1000;
        section.find('.stepval').innerHTML  = Math.round(step*100000)/100000;

        // get the clamped values
        var clamps = [];
        parameters.forEach(function(clamp) {
          var val = parseFloat(section.find('div[type=range].label'+clamp).get("value"));
          clamps.push({ label: clamp, value: val });
        });

        // construct the plotting options object
        var options = {
          width: 400,
          height: 200,
          variable: { label: 'x', start: start, end: end, step: step },
          clamped: clamps
        };

        // plot the plotting viewbox
        var viewbox = {
          minx: parseFloat(section.querySelector(".v_minx").value),
          maxx: parseFloat(section.querySelector(".v_maxx").value),
          miny: parseFloat(section.querySelector(".v_miny").value),
          maxy: parseFloat(section.querySelector(".v_maxy").value),
          axes: { x: 0, y: 0 }
        };

        // and finally, plot the math function onto the page
        mathFunction.clear();
        mathFunction.plot(plotDiv, options, viewbox);
      }
    </script>

    <!--
      page code loading, using head.js so that we're assure a load order.
    -->
    <script>
      head.js(
        'toolkit/ttk.js',
        'toolkit/ttk-range.js',
        'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML',
        'FunctionTree.js',
        'Tape.js',
        'ArithmeticFragment.js',
        'SimpleNodes.js',
        'OperatorNodes.js',
        'FunctionNodes.js',
        'AggregatorNodes.js',
        'MathFunction.js',
        'tabbing/tabbing.js',
        // final callback
        function() {
          // turn sections into tabs
          setupTabs();
          var activeSections = document.querySelectorAll('section[class=tabbed]');
          activeSections.forEach(function(s) {
            s.onreveal = function() { setTimeout(plot, 50); }
          })
          // show initial function
          plot();
        }
      );
    </script>
  </body>
</html>
